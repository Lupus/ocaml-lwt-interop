; Generated by rust-staticlib-gen for opam package: rust-async


; Generated by rust-staticlib-gen. Do not edit by hand!
; Run `dune runtest` to regenerate.

; Rules in this file generate cargo crate with the so called rust staticlib.
; This crate depends on all the crates, which are marked as Rust stubs by
; `x-rust-stubs-crate` metadata field in corresponding opam packages that your
; opam file depend on. The Rust staticlib crate re-exports all the dependencies
; and builds statically and dynamically linked libraries, which consequently
; have all the defined symbols which are used by OCaml bindings.


; This alias includes generation of all Rust-related bits in staticlib.
(alias
  (name populate-rust-staticlib))

; Create Cargo.toml file in this folder within source directory
(rule
  (alias populate-rust-staticlib)
  (targets Cargo.toml)
  (mode promote) ; promote back to source dir
  (action
    (write-file ; file contents
      Cargo.toml
      "# Generated by rust-staticlib-gen for opam package: rust-async\n\n# This crate depends on all Rust crates, that were specified via\n# `x-rust-stubs-crate` metadata field in opam files in the dependencie tree of your\n# project opam file.\n#\n# Dependencies are listed as exact version matches, and versions are taken\n# verbatim from corresponding opam package versions. This is done this way to\n# ensure 100% compatibility between OCaml bindings and their Rust stubs crates.\n# In case of any confclits at cargo level, they should be resolved at opam\n# level, and this file needs to be re-generated.\n\n\n[package]\nname = \"rust-staticlib-rust-async\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]\npath = \"lib.rs\"\n\n[dependencies]\n# Declared by local opam package (rust-async)\nocaml-lwt-interop = { path = \"..\" }\n# Declared by: opam package `ocaml-rs-smartptr.0.1.0'\nocaml-rs-smartptr = { version = \"=0.1.0\" }\n# Declared by: command-line arguments\nocaml-lwt-interop-test-stubs = { path = \"../test-stubs\" }\n")))

; Create lib.rs file in this folder within source directory
(rule
  (alias populate-rust-staticlib)
  (targets lib.rs)
  (mode promote) ; promote back to source dir
  (action
    (write-file ; file contents
      lib.rs
      "/* Generated by rust-staticlib-gen */\n\npub use ocaml_lwt_interop;\npub use ocaml_lwt_interop_test_stubs;\npub use ocaml_rs_smartptr;\n")))

; Create Rust_staticlib.ml file in this folder within build directory only
(rule
  (targets Rust_staticlib.ml)
  (action
    (write-file ; file contents
      Rust_staticlib.ml
      "(* Generated by rust-staticlib-gen *)\n\nlet please_generate_and_link_rust_staticlib = ()\n\n")))


; This rule generates an S-expression file to be included into dune's rule
; `(deps)` section later. Inside this S-expression file will be full list of
; Rust-related dependencies in project source tree (Rust sources and Cargo
; manifests and lock file).
; Make sure to exclude `target` Rust output dir by using `dirs` stanza in
; project root like this:
;   (dirs :standard \ target)
; Otherwise dune's glob_files_rec would scan everything in `target` dir as well,
; possibly causing problems.

(rule
 (target rust-deps.inc)
 (deps
  (alias populate-rust-staticlib)
  (glob_files_rec %{workspace_root}/*.rs)
  (glob_files_rec %{workspace_root}/Cargo.toml)
  (glob_files_rec %{workspace_root}/Cargo.lock))
 (action
  (with-stdout-to %{target}
   (echo "(%{deps})"))))

; Below alias is handy if you want to depend on changes to any Rust/Cargo
; sources in your project, you can safely depend on it outside of this subdir

(alias
 (name rust-universe)
 (deps
  (include rust-deps.inc) ; depend on all Rust bits in your project
  (alias populate-rust-staticlib))) ; and on Rust staticlib generation

; Below rule actually compiles Rust staticlib, using a wrapper tool which
; invokes cargo and copies the resulting artifacts into current directory.
; Cargo has a flag to do that on its own, but it's still unstable.
; see https://github.com/rust-lang/cargo/issues/6790

(rule
 (targets
  "librust_staticlib_rust_async%{ocaml-config:ext_lib}"
  "dllrust_staticlib_rust_async%{ocaml-config:ext_dll}")
 (deps
  (alias rust-universe) ; rebuild only if Rust bits change, linking is slow
  Cargo.toml)
 (locks cargo-build)
 (action
  (run dune-cargo-build
   --profile=%{profile}
   --workspace-root=%{workspace_root}
   ./Cargo.toml)))

; This library is deliberately very lightweight from OCaml perspective. It's
; only purpose is to drag Rust stubs static lib into the final executable
; linkage by dune.  Bear in mind that two libs like this can not be linked into
; one binary, as static libs produced by Rust expose all Rust stdlib symbols,
; and linking will explode with collision errors.
;
; The `Rust_staticlib` module implements the interface of the virtual library
; `rust-staticlib`.  This virtual library exists to notify users that there are
; Rust dependencies that need Rust staticlib to be generated. Each Rust
; staticlib actually implements this dummy interface via this generated file.
; This allows to communicate Rust dependency requirements to the end user in a
; bit nicier way than via the linker errors.
;


(library
 (name rust_async_stubs)
 (foreign_archives rust_staticlib_rust_async) ; link Rust bits into the final executable
 (modules Rust_staticlib) ; generated virtual lib implementation
 (implements rust-staticlib-virtual) ; mark this lib as the one implementing rust-staticlib
 (c_library_flags
  (-lpthread -lc -lm)))
