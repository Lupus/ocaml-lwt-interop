searchState.loadedDescShard("ocaml_lwt_interop", 0, "This library extends the functionality provided by the …\nAn extension on top of <code>OCamlFunc</code> for asynchronous functions\nThis module provides an executor for OCaml domains, …\nThis module provides an implementation of a <code>Future</code> called …\nThis module provides an interface to Lwt-specific …\nThe <code>Promise</code>, <code>Resolver`` and </code>PromiseFuture…\nStubs exported to OCaml from this crate. Do not use from …\nAn extension on top of <code>OCamlFunc</code> for asynchronous …\nCalls inner OCamlFunc, assuming it’s return value is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new OCamlAsyncFunc out of <code>v</code>.\nAn executor designed to run within an OCaml domain.\nA driver for the <code>DomainExecutor</code>, responsible for running …\nA guard that manages the lifetime of an executor context …\nA handle to the OCaml domain executor, allowing tasks to …\nA guard that provides access to the OCaml runtime handle …\nThe driver that runs the executor.\nDrops the guard, removing the executor context from the …\nEnters the executor context, pushing it onto the …\nThe async executor instance.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a handle to the current OCaml Domain executor.\nReturns a handle to the executor obtained from the OCaml …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>DomainExecutor</code> with the given notification.\nObtains a guard to access the OCaml runtime handle.\nRuns a closure <code>f</code> within the OCaml domain, ensuring the …\nThe Tokio runtime used for asynchronous I/O.\nSpawns a future onto the current executor.\nSpawns a new future onto the executor.\nSpawns a future onto the executor associated with this …\nSpawns a future onto the executor obtained from the OCaml …\nSpawns a future onto the executor obtained from the OCaml …\nTicks the executor, polling its future to drive task …\nTicks the executor, driving task execution.\nReturns a reference to the global Tokio runtime.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA future that represents a computation which will …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>MlBoxFuture</code>.\nPolls the future to check if it has been resolved or …\nRejects the future with the given error message.\nResolves the future with the given <code>MlBox</code> value.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>Promise&lt;T&gt;</code> is a wrapper around ocaml::Value which is …\n<code>PromiseFuture&lt;T&gt;</code> bridges a <code>Promise&lt;T&gt;</code> (an OCaml promise) …\n<code>Resolver&lt;T&gt;</code> is a wrapper around ocaml::Value which is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new promise/resolver pair, calls <code>Lwt.task</code> under …\nWraps underlying OCaml type with <code>&#39;a Lwt.t</code>\n<code>PromiseFuture&lt;T&gt;</code> must only be polled from a task, which is …\nRejects the <code>&#39;a Lwt.u</code> via <code>Lwt.wakeup_later_exn</code>\nResolves the <code>&#39;a Lwt.u</code> via <code>Lwt.wakeup_later</code>\nHashes underlying unique_id with unique key")